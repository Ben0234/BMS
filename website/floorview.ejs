<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
  <%- include("./header") %>
</head>

<body>
  <div class="table-active">
    <div class="row title" style="height: 4vh">
      <div class="col-4 text-center mt-2 justify-text-center " style="background-color: rgba(240, 248, 255, 0);">
        <h3>Floorplan</h3>
      </div>
      <div class="col-4 text-center mt-2 justify-text-center ">
        <h3>Energy Usage</h3>
      </div>
    </div>
    <div class="row" style="height: 44vh">
      <div class="col-4 m-3">
        <canvas class="p-0" id="shadeCanvas" style="position: absolute; z-index: -1; width: 600px; height: 400px"></canvas>
        <img src="https://placehold.co/600x400" alt="" id="floorplan" style="position: absolute; top: 0; left: 0" usemap="#testmap" />
      </div>
      <div class="col-4 m-3" style="overflow: auto; height: 100%">
        <div class="table" id="gaugeTable">
        </div>
      </div>
    </div>
    <div class="row title" style="height:5vh"></div>
  </div>

  <br />
  <map name="testmap" id="testmap">

  </map>

  <!-- Modal -->
  <div id="infoModal" class="modal p-3" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Modal title</h5>
          <button class="btn btn-secondary" style="position: absolute; top: 10px; right: 10px" id="editButton">
            Edit
          </button>
        </div>
        <div class="modal-body">
          <p>Modal body text goes here.</p>
          <canvas id="tempChart"></canvas>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" onclick="closeModal()">
            Close
          </button>
        </div>
      </div>
    </div>
  </div>
  <script>
    var ejsData = <%- JSON.stringify(data) %>;
  </script>
  <script>
    var orginalSensorData = <%- JSON.stringify(sensorData) %>;


    function loadData() {
      for (var data in ejsData) {
        var option = document.createElement('option');
        option.value = ejsData[data].floorlevel;
        option.text = "Floor " + ejsData[data].floorlevel; // Assuming you want to use the same value for the display text
        $("#zoneSelector").append(option);
      }
      floorlevel = $("#zoneSelector").val();
      zones = ejsData[floorlevel - 1].zones;
      for (zone in zones) {
        var timestampTemperaturePairs = []; // Changed from timestampZonePairs
        for (data in orginalSensorData) {
          if (orginalSensorData[data].metaData.zone == zones[zone].name && orginalSensorData[data].metaData.floor == floorlevel) {
            timestampTemperaturePairs.push({
              floor: orginalSensorData[data].metaData.floor,
              zone:orginalSensorData[data].metaData.zone,
              temperature: orginalSensorData[data].temperature,
              timestamp: orginalSensorData[data].timestamp,
              setTemperature: orginalSensorData[data].setTemperature,
              upperMargin: orginalSensorData[data].setTemperature +
                orginalSensorData[data].upperMargin,
              lowerMargin: orginalSensorData[data].setTemperature -
                orginalSensorData[data].lowerMargin,
            });
          }
          sensorData[zones[zone].name] = timestampTemperaturePairs; // Correct variable name
        }
      }
    }
  </script>
  <script>
    var timestampTemperaturePairs = [];
    var zones;
    var imagemap = document.getElementById("testmap");
    var floorplan = ejsData[0].floorplan;
    var modal = document.getElementById("infoModal");
    var shadeCanvas = document.getElementById("shadeCanvas");
    var ctx = shadeCanvas.getContext("2d");
    var dynamicCharts = {};
    var image = document.querySelector("img");
    image.src = floorplan;
    var sensorData = {};
    loadData();
    socket.on("sensorData", function(data) {
      orginalSensorData = data.sensorData;
      console.log("received sensor data");
      loadData();
      createArea();
      updatetemperature();
      console.log(dynamicCharts);
    });
    window.addEventListener("click", function(event) {
      if (event.target == modal) {
        closeModal();
      }
    });
    createArea();
    updatetemperature();

    function openModal() {
      modal.style.display = "block";
    }

    function closeModal() {
      document.getElementById("editButton").style.display = "block";
      var updateElement = document.getElementById("update");
      if (updateElement) {
        updateElement.remove();
      }

      modal.style.display = "none";
    }

    function createArea() {
      while (imagemap.firstChild) {
        imagemap.removeChild(imagemap.firstChild);
      }
      for (var zone in zones) {
        var coordinates = zones[zone];
        var area = document.createElement("area");

        area.setAttribute("shape", "rect");
        area.setAttribute(
          "coords",
          coordinates.startX +
          "," +
          coordinates.startY +
          "," +
          coordinates.endX +
          "," +
          coordinates.endY
        );
        area.setAttribute("href", "#");
        area.setAttribute("id", zones[zone].name);
        imagemap.appendChild(area);
      }
      $("img").mapster({
        showToolTip: true,
        mapKey: "id",
        singleSelect: true,
        fillOpacity: 0.2,
        onClick: function(e) {
          console.log(e.key);
          openModal();
          modal.querySelector(".modal-title").textContent = e.key;

          for (zone in zones) {
            if (e.key == zones[zone].name) {
              modal.querySelector(".modal-body").textContent =
                "Temperature Set: " +
                sensorData[zones[zone].name][0].setTemperature +
                "C";
              // create modal body elements
              var div = document.createElement("div");
              modal.querySelector(".modal-body").appendChild(div);
              var div = document.createElement("div");


              modal.querySelector(".modal-body").appendChild(div);

              var canvas = document.createElement("canvas");
              canvas.id = "tempChart";
              canvas.style.width = "100%";
              canvas.style.height = "300px";
              modal.querySelector(".modal-body").appendChild(canvas);
            }
          }
          loadTempChart(e.key);
        },
      });
      var areaOptions = {
        key: zones[zone].name,
        toolTip: "temperature Set: " +
          sensorData[zones[zone].name][0].setTemperature +
          "C",
      };
      $("img").mapster("set_options", {
        areas: [{
          key: areaOptions.key,
          toolTip: areaOptions.toolTip,
        }, ],
      });
    }

    function updatetemperature() {
      ctx.clearRect(0, 0, shadeCanvas.width, shadeCanvas.height);
      var temp;
      for (var zone in zones) {
        for (var data in sensorData) {
          if (sensorData[data].zone == zones[zone].name) {
            temp = sensorData[data].temperature;
          }
        }
        var areaOptions = {
          key: zones[zone].name,
          toolTip: "temperature Set: " +
            sensorData[zones[zone].name][0].setTemperature +
            "C",
        };
        $("img").mapster("set_options", {
          areas: [{
            key: areaOptions.key,
            toolTip: areaOptions.toolTip,
          }, ],
        });
        var zonePosition = zones[zone];
        var startX = (zonePosition.startX / 600) * shadeCanvas.width;
        var startY = (zonePosition.startY / 400) * shadeCanvas.height;
        var endX = (zonePosition.endX / 600) * shadeCanvas.width;
        var endY = (zonePosition.endY / 400) * shadeCanvas.height;

        var temperatureGradient =
          (sensorData[zones[zone].name][0].temperature -
            sensorData[zones[zone].name][0].lowerMargin) /
          (sensorData[zones[zone].name][0].upperMargin -
            sensorData[zones[zone].name][0].lowerMargin);
        var red = Math.round(255 * temperatureGradient);
        var blue = Math.round(255 * (1 - temperatureGradient));
        ctx.fillStyle = "rgba(" + red / 2 + ", 255, " + blue + ", 0.5)";

        ctx.beginPath();
        if (endX > startX) {
          var width = Math.abs(endX - startX);
          if (endY > startY) {
            var height = Math.abs(endY - startY);
            ctx.rect(startX, startY, width, height);
          } else {
            var height = Math.abs(startY - endY);
            ctx.rect(startX, endY, width, height);
          }
        } else {
          var width = Math.abs(startX - endX);
          if (endY > startY) {
            var height = Math.abs(endY - startY);
            ctx.rect(endX, startY, width, height);
          } else {
            var height = Math.abs(startY - endY);
            ctx.rect(endX, endY, width, height);
          }
        }
        ctx.fill();
      }
    }



    $("#editButton").click(function() {
      var name = modal.querySelector(".modal-title").textContent;
      modal.querySelector(".modal-title").textContent = "Edit " + modal.querySelector(".modal-title").textContent;
      modal.querySelector(".modal-header");
      document.getElementById("editButton").style.display = "none";
      var div = document.createElement("div");
      div.textContent = "set temp: ";
      var setTempInput = document.createElement("input");
      setTempInput.id = "setInput";
      setTempInput.type = "number";
      setTempInput.value =
        sensorData[name][0].setTemperature;

      var margin = document.createElement("div");
      margin.textContent = "margin: ";
      var marginInput = document.createElement("input");
      marginInput.id = "Margin";
      marginInput.type = "number";
      marginInput.value = (-(sensorData[name][0].setTemperature - sensorData[name][0].upperMargin));
      margin.appendChild(marginInput);

      var button = document.createElement("button");
      button.classList.add("btn", "ms-3", "btn-primary");
      button.textContent = "update";
      button.id = "update";
      button.addEventListener("click", function() {
        var newTemp = setTempInput.value;
        var newMargin = marginInput.value;
        socket.emit("setTemperature", {
          temperature: newTemp,
          margin: newMargin
        });
        modal.querySelector(".modal-footer").removeChild(button);
        closeModal();
      }); 
      modal.querySelector(".modal-body").innerHTML = "";
      modal.querySelector(".modal-body").appendChild(div);
      div.appendChild(setTempInput);
      div.appendChild(margin);
      modal.querySelector(".modal-footer").appendChild(button);
    });
    updatetemperature();
  </script>
  <script>
    function createGauge() {
      count = 0;
      for (var zone in zones) {
        if (count % 2 == 0) {
          var row = document.createElement("div");
          row.classList.add("row");
          row.id = "row" + count;
          $("#gaugeTable").append(row);
          var gaugeData = {
            datasets: [{
              label: zones[zone].name,
              data: [200, 200, 200],
              backgroundColor: [
                "rgba(255, 0, 0, 0.2)",
                "rgba(0, 255, 0, 0.2)",
                "rgba(0, 0, 255, 0.2)",
              ],
              borderColor: [
                "rgba(255, 0, 0, 0.2)",
                "rgba(0, 255, 0, 0.2)",
                "rgba(0, 0, 255, 0.2)",
              ],
              borderWidth: 1,
              circumference: 180,
              rotation: -90,
              cutout: "80%",
              needle: 300,
            }, ],
          };
          var gaugeNeedle = {
            id: "gaugeNeedle",
            afterDatasetsDraw(chart, args, plugins) {
              const {
                ctx,
                data
              } = chart;
              ctx.save();
              const xCenter = chart.getDatasetMeta(0).data[0].x;
              const yCenter = chart.getDatasetMeta(0).data[0].y;

              const outerRadius = chart.getDatasetMeta(0).data[0].outerRadius;
              const innerRadius = chart.getDatasetMeta(0).data[0].innerRadius;
              const widthSlice = (outerRadius - innerRadius) / 2;
              const radius = 15;
              const angle = Math.PI / 180;

              const needleValue = data.datasets[0].needleValue;

              const dataTotal = data.datasets[0].data.reduce((a, b) => a + b, 0);
              const circumference =
                (chart.getDatasetMeta(0).data[0].circumference /
                  Math.PI /
                  data.datasets[0].data[0]) *
                data.datasets[0].needle;

              ctx.translate(xCenter, yCenter);
              ctx.rotate(Math.PI * (circumference + 1.5));
              //needle
              ctx.beginPath();
              ctx.strokeStyle = "grey";
              ctx.fillStyle = "grey";
              ctx.moveTo(0 - 15, 0);
              ctx.lineTo(0, 0 - innerRadius - widthSlice);
              ctx.lineTo(0 + 15, 0);
              ctx.closePath();
              ctx.stroke();
              ctx.fill();

              //dot
              ctx.beginPath();
              ctx.arc(0, 0, radius, 0, angle * 360, false);
              ctx.fill();
              ctx.restore();
            },
          };
          const gaugeFlowMeter = {
            id: "gaugeFlowMeter",
            afterDatasetsDraw(chart, args, plugins) {
              const {
                ctx,
                data
              } = chart;

              ctx.save();
              const needleValue = data.datasets[0].needleValue;
              const xCenter = chart.getDatasetMeta(0).data[0].x;
              const yCenter = chart.getDatasetMeta(0).data[0].y;
              const chartMetaData = chart.getDatasetMeta(0);

              const circumference =
                (chart.getDatasetMeta(0).data[0].circumference /
                  Math.PI /
                  data.datasets[0].data[0]) *
                data.datasets[0].needle;

              //flowmeter
              ctx.fillStyle = "black";
              ctx.font = "30px Arial";
              ctx.textAlign = "center";
              ctx.fillText(data.datasets[0].needle + " kwh", xCenter, yCenter + 40);
            },
          };
          const gaugeLabels = {
            id: "gaugeLabels",
            afterDatasetsDraw(chart, args, plugins) {
              const {
                ctx,
                data
              } = chart;
              ctx.save();
              const xCenter = chart.getDatasetMeta(0).data[0].x;
              const yCenter = chart.getDatasetMeta(0).data[0].y;
              const outer = chart.getDatasetMeta(0).data[0].outerRadius;
              const inner = chart.getDatasetMeta(0).data[0].innerRadius;
              ctx.fillStyle = "black";
              ctx.font = "30px Arial";
              ctx.textAlign = "center";
              ctx.fillText(data.datasets[0].label, xCenter, yCenter - outer - 10);
              ctx.restore();
            },
          };
          const chartAreaBorder = {
            id: "chartAreaBorder",
            beforeDraw(chart, args, options) {
              const {
                ctx,
                chartArea: {
                  left,
                  top,
                  width,
                  height
                },
              } = chart;
              const margin = 10;
              const leftMargin = left - margin;
              const topMargin = top - margin;
              const widthMargin = width + 2 * margin;
              const heightMargin = height + 2 * margin;
              ctx.strokeRect(leftMargin, topMargin, widthMargin, heightMargin);
              ctx.save();
              ctx.restore();
            },
          };
          const gaugeConfig = {
            type: "doughnut",
            data: gaugeData,
            options: {
              layout: {
                padding: 20,
              },
              animation: {
                animateRotate: false, // Disable rotation animation
              },
              aspectRatio: 1.2,
              plugins: {
                legend: {
                  display: false,
                },
                tooltip: {
                  enabled: false,
                },
              },
            },
            plugins: [gaugeNeedle, gaugeFlowMeter, gaugeLabels, chartAreaBorder],
          };
          var canvas = document.createElement("canvas");
          var col = document.createElement("div");
          canvas.id = "gauge" + zones[zone].name;
          canvas.style.width = "100%";
          canvas.style.height = "300px";
          var row = document.getElementById("row" + count);
          col.classList.add("col-6");
          col.appendChild(canvas);
          row.appendChild(col);
          var ctx = canvas.getContext("2d");
          dynamicCharts["gauge" + count] = new Chart(ctx, gaugeConfig);
          count++;
        } else {
          var gaugeData = {
            datasets: [{
              label: zones[zone].name,
              data: [200, 200, 200],
              backgroundColor: [
                "rgba(255, 0, 0, 0.2)",
                "rgba(0, 255, 0, 0.2)",
                "rgba(0, 0, 255, 0.2)",
              ],
              borderColor: [
                "rgba(255, 0, 0, 0.2)",
                "rgba(0, 255, 0, 0.2)",
                "rgba(0, 0, 255, 0.2)",
              ],
              borderWidth: 1,
              circumference: 180,
              rotation: -90,
              cutout: "80%",
              needle: 300,
            }, ],
          };
          var gaugeNeedle = {
            id: "gaugeNeedle",
            afterDatasetsDraw(chart, args, plugins) {
              const {
                ctx,
                data
              } = chart;
              ctx.save();
              const xCenter = chart.getDatasetMeta(0).data[0].x;
              const yCenter = chart.getDatasetMeta(0).data[0].y;

              const outerRadius = chart.getDatasetMeta(0).data[0].outerRadius;
              const innerRadius = chart.getDatasetMeta(0).data[0].innerRadius;
              const widthSlice = (outerRadius - innerRadius) / 2;
              const radius = 15;
              const angle = Math.PI / 180;

              const needleValue = data.datasets[0].needleValue;

              const dataTotal = data.datasets[0].data.reduce((a, b) => a + b, 0);
              const circumference =
                (chart.getDatasetMeta(0).data[0].circumference /
                  Math.PI /
                  data.datasets[0].data[0]) *
                data.datasets[0].needle;

              ctx.translate(xCenter, yCenter);
              ctx.rotate(Math.PI * (circumference + 1.5));
              //needle
              ctx.beginPath();
              ctx.strokeStyle = "grey";
              ctx.fillStyle = "grey";
              ctx.moveTo(0 - 15, 0);
              ctx.lineTo(0, 0 - innerRadius - widthSlice);
              ctx.lineTo(0 + 15, 0);
              ctx.closePath();
              ctx.stroke();
              ctx.fill();

              //dot
              ctx.beginPath();
              ctx.arc(0, 0, radius, 0, angle * 360, false);
              ctx.fill();
              ctx.restore();
            },
          };
          const gaugeFlowMeter = {
            id: "gaugeFlowMeter",
            afterDatasetsDraw(chart, args, plugins) {
              const {
                ctx,
                data
              } = chart;

              ctx.save();
              const needleValue = data.datasets[0].needleValue;
              const xCenter = chart.getDatasetMeta(0).data[0].x;
              const yCenter = chart.getDatasetMeta(0).data[0].y;
              const chartMetaData = chart.getDatasetMeta(0);

              const circumference =
                (chart.getDatasetMeta(0).data[0].circumference /
                  Math.PI /
                  data.datasets[0].data[0]) *
                data.datasets[0].needle;

              //flowmeter
              ctx.fillStyle = "black";
              ctx.font = "30px Arial";
              ctx.textAlign = "center";
              ctx.fillText(data.datasets[0].needle + " kwh", xCenter, yCenter + 40);
            },
          };
          const gaugeLabels = {
            id: "gaugeLabels",
            afterDatasetsDraw(chart, args, plugins) {
              const {
                ctx,
                data
              } = chart;
              ctx.save();
              const xCenter = chart.getDatasetMeta(0).data[0].x;
              const yCenter = chart.getDatasetMeta(0).data[0].y;
              const outer = chart.getDatasetMeta(0).data[0].outerRadius;
              const inner = chart.getDatasetMeta(0).data[0].innerRadius;
              ctx.fillStyle = "black";
              ctx.font = "30px Arial";
              ctx.textAlign = "center";
              ctx.fillText(data.datasets[0].label, xCenter, yCenter - outer - 10);
              ctx.restore();
            },
          };
          const chartAreaBorder = {
            id: "chartAreaBorder",
            beforeDraw(chart, args, options) {
              const {
                ctx,
                chartArea: {
                  left,
                  top,
                  width,
                  height
                },
              } = chart;
              const margin = 10;
              const leftMargin = left - margin;
              const topMargin = top - margin;
              const widthMargin = width + 2 * margin;
              const heightMargin = height + 2 * margin;
              ctx.strokeRect(leftMargin, topMargin, widthMargin, heightMargin);
              ctx.save();
              ctx.restore();
            },
          };
          const gaugeConfig = {
            type: "doughnut",
            data: gaugeData,
            options: {
              layout: {
                padding: 20,
              },
              animation: {
                animateRotate: false, // Disable rotation animation
              },
              aspectRatio: 1.2,
              plugins: {
                legend: {
                  display: false,
                },
                tooltip: {
                  enabled: false,
                },
              },
            },
            plugins: [gaugeNeedle, gaugeFlowMeter, gaugeLabels, chartAreaBorder],
          };
          var canvas = document.createElement("canvas");
          var col = document.createElement("div");
          canvas.id = "gauge" + zones[zone].name;
          canvas.style.width = "100%";
          canvas.style.height = "300px";
          var row = document.getElementById("row" + (count - 1));
          col.classList.add("col-6");
          col.appendChild(canvas);
          row.appendChild(col);
          var ctx = canvas.getContext("2d");
          dynamicCharts["gauge" + count] = new Chart(ctx, gaugeConfig);
          count++;
        }
      }
    }
    console.log(dynamicCharts);
    var testbutton = document.createElement("button");
    testbutton.textContent = "test";
    testbutton.addEventListener("click", function() {
    dynamicCharts.gauge0.data.datasets[0].needle = (Math.floor(Math.random() * 601)).toFixed(2);
      dynamicCharts.gauge0.update();
      console.log(dynamicCharts.gauge0.data.datasets[0].needle);
    })
    document.body.appendChild(testbutton);
    createGauge();

    function loadTempChart(key) {
      var temp = [];
      var upper = [];
      var lower = [];
      var set = [];
      var labels = [];

      var dynamicChartName = "myChart1_" + key;

      // Get the sensor data for the given zone key
      var zoneData = sensorData[key];
      if (zoneData) {
        // Iterate over the sensor data and push to temp and labels arrays
        for (var i = 0; i < zoneData.length; i++) {
          temp.push(zoneData[i].temperature.toFixed(2));
          labels.push(zoneData[i].timestamp.split("T")[1].substring(0, 8));
          upper.push(zoneData[i].upperMargin);
          lower.push(zoneData[i].lowerMargin);
          set.push(zoneData[i].setTemperature);
        }
      }
      temp.reverse();
      labels.reverse();
      upper.reverse();
      lower.reverse();
      set.reverse();

      var tempChart = document.getElementById("tempChart");
      var tempCtx = tempChart.getContext("2d");
      var time = new Date().toISOString().split("T")[1].substring(0, 8);
      var data = {
        labels: labels,
        datasets: [{
            label: "temperature",
            data: temp,
            fill: false,
            hoverBackgroundColor: "rgba(75, 192, 192, 0.4)",
            borderColor: "rgb(75, 192, 192)",
            tension: 0.1,
            pointstyle: "dash",
          },
          {
            label: "uppermargin",
            data: upper,
            fill: false,
            borderColor: "red",
            tension: 0.1,
            pointStyle: "dash",
          },
          {
            label: "lowermargin",
            data: lower,
            fill: false,
            borderColor: "blue",
            tension: 0.1,
            pointstyle: "dash",
          },
          {
            label: "set Temperature",
            data: set,
            fill: false,
            borderColor: "green",
            tension: 0.1,
            pointstyle: "dash",
          },
        ],
      };
      var tempConfig = {
        type: "line",
        data: data,
        options: {
          plugins: {
            legend: {
              display: false, // Remove legend
            },
          },
        },
      };

      dynamicCharts[dynamicChartName] = new Chart(tempCtx, tempConfig);

    }
    updatetemperature();
  </script>
</body>

</html>