<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <%- include("./header") %>
  </head>

  <body>
    <div class="table">
      <div class="row" style="height: 50vh">
        <div class="col-4 m-3">
          <canvas
            class="p-0"
            id="shadeCanvas"
            style="position: absolute; z-index: -1; width: 600px; height: 400px"
          ></canvas>
          <img
            src="https://placehold.co/600x400"
            alt=""
            id="floorplan"
            style="position: absolute; top: 0; left: 0"
            usemap="#testmap"
          />
        </div>
        <div class="col-4" style="overflow: auto; height: 100%">
          <div class="table">
            <div class="row">
              <div class="col">
                <canvas
                  class="p-0"
                  id="myChart1"
                  style="width: 200px; height: 300px"
                ></canvas>
              </div>
              <div class="col">
                <canvas
                  class="p-0"
                  id="myChar2t"
                  style="width: 200px; height: 300px"
                ></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <br />
    <map name="testmap" id="testmap">
      <area shape="rect" id="rect1" coords="0,0,100,100" href="" alt="" />
    </map>

    <!-- Modal -->
    <div id="infoModal" class="modal p-3" tabindex="-1" role="dialog">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Modal title</h5>
          </div>
          <div class="modal-body">
            <p>Modal body text goes here.</p>
            <canvas id="tempChart"></canvas>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              onclick="closeModal()"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>
    <script>
      var ejsData = <%- JSON.stringify(data) %>;
    </script>
    <script>
      var sensorData = <%- JSON.stringify(sensorData) %>;
    </script>
    <script>
      var timestampTemperaturePairs = [];
      var zoneData = [
        {
          temperature: 20,
          humidity: 50,
          name: "zone1",
          setTemperature: 25,
          margin: 3,
          time: new Date(),
        },
        {
          temperature: 30,
          humidity: 50,
          setTemperature: 25,
          margin: 3,
          name: "zone2",
          time: new Date(),
        },
        {
          temperature: 10,
          humidity: 50,
          setTemperature: 25,
          margin: 3,
          name: "zone3",
          time: new Date(),
        },
      ];
      var zones;
      var imagemap = document.getElementById("testmap");
      var floorplan = ejsData[0].floorplan;
      var modal = document.getElementById("infoModal");
      var shadeCanvas = document.getElementById("shadeCanvas");
      var ctx = shadeCanvas.getContext("2d");

      var image = document.querySelector("img");
      image.src = floorplan;
      zones = ejsData[0].zones;

      var sensordata = {};
      for (zone in zones) {
        var timestampTemperaturePairs = []; // Changed from timestampZonePairs
        for (data in sensorData) {
          if (sensorData[data].metaData.zone == zones[zone].name) {
            timestampTemperaturePairs.push({
              zone: zones[zone].name,
              temperature: sensorData[data].temperature,
              timestamp: sensorData[data].timestamp,
              setTemperature: sensorData[data].setTemperature,
              upperMargin:
                sensorData[data].setTemperature + sensorData[data].upperMargin,
              lowerMargin:
                sensorData[data].setTemperature - sensorData[data].lowerMargin,
            });
          }
          sensordata[zones[zone].name] = timestampTemperaturePairs; // Correct variable name
        }
      }
      console.log(sensordata);
      function openModal() {
        modal.style.display = "block";
      }

      function closeModal() {
        modal.style.display = "none";
      }

      function createArea() {
        for (var zone in zones) {
          var coordinates = zones[zone];
          var area = document.createElement("area");
          area.setAttribute("shape", "rect");
          area.setAttribute(
            "coords",
            coordinates.startX +
              "," +
              coordinates.startY +
              "," +
              coordinates.endX +
              "," +
              coordinates.endY
          );
          area.setAttribute("href", "#");
          area.setAttribute("id", zones[zone].name);
          imagemap.appendChild(area);
        }
      }
      $("img").mapster({
        showToolTip: true,
        mapKey: "id",
        singleSelect: true,
        fillOpacity: 0.2,
        onClick: function (e) {
          console.log(e.key); // Access the area key through the event object
          openModal();
          modal.querySelector(".modal-title").textContent = e.key;
          for (zone in zones) {
            if (e.key == zones[zone].name) {
              modal.querySelector(".modal-body").textContent =
                "Temperature is " + zoneData[zone].temperature + "C";
              var canvas = document.createElement("canvas");
              canvas.id = "tempChart";
              canvas.style.width = "100%";
              canvas.style.height = "300px";
              modal.querySelector(".modal-body").appendChild(canvas);
            }
          }
          loadTempChart(e.key);
        },
      });

      window.onclick = function (event) {
        if (event.target == modal) {
          modal.style.display = "none";
          $("#Zone1").mapster("deselect");
        }
      };

      function updatetemperature() {
        ctx.clearRect(0, 0, shadeCanvas.width, shadeCanvas.height);
        var temp;
        for (var zone in zones) {
          for (var data in sensorData) {
            if (sensorData[data].zone == zones[zone].name) {
              temp = sensorData[data].temperature;
            }
          }
          var areaOptions = {
            key: zones[zone].name,
            toolTip:
              "temperature is " +
              sensordata[zones[zone].name][0].temperature +
              "C",
          };
          $("img").mapster("set_options", {
            areas: [
              {
                key: areaOptions.key,
                toolTip: areaOptions.toolTip,
              },
            ],
          });
          var zonePosition = zones[zone];
          var startX = (zonePosition.startX / 600) * shadeCanvas.width;
          var startY = (zonePosition.startY / 400) * shadeCanvas.height;
          var endX = (zonePosition.endX / 600) * shadeCanvas.width;
          var endY = (zonePosition.endY / 400) * shadeCanvas.height;

          var temperatureGradient =
            (sensordata[zones[zone].name][0].temperature -
              sensordata[zones[zone].name][0].lowerMargin) /
            (sensordata[zones[zone].name][0].upperMargin -
              sensordata[zones[zone].name][0].lowerMargin);
          var red = Math.round(255 * temperatureGradient);
          var blue = Math.round(255 * (1 - temperatureGradient));
          ctx.fillStyle = "rgba(" + red / 2 + ", 255, " + blue + ", 0.5)";

          ctx.beginPath();
          if (endX > startX) {
            var width = Math.abs(endX - startX);
            if (endY > startY) {
              var height = Math.abs(endY - startY);
              ctx.rect(startX, startY, width, height);
            } else {
              var height = Math.abs(startY - endY);
              ctx.rect(startX, endY, width, height);
            }
          } else {
            var width = Math.abs(startX - endX);
            if (endY > startY) {
              var height = Math.abs(endY - startY);
              ctx.rect(endX, startY, width, height);
            } else {
              var height = Math.abs(startY - endY);
              ctx.rect(endX, endY, width, height);
            }
          }
          ctx.fill();
        }
      }

      createArea();
      updatetemperature();
    </script>
    <script>
      var gaugeData = {
        datasets: [
          {
            label: "Zone 1",
            data: [200, 200, 200],
            backgroundColor: [
              "rgba(255, 0, 0, 0.2)",
              "rgba(0, 255, 0, 0.2)",
              "rgba(0, 0, 255, 0.2)",
            ],
            borderColor: [
              "rgba(255, 0, 0, 0.2)",
              "rgba(0, 255, 0, 0.2)",
              "rgba(0, 0, 255, 0.2)",
            ],
            borderWidth: 1,
            circumference: 180,
            rotation: -90,
            cutout: "80%",
            needle: 300,
          },
        ],
      };

      var gaugeNeedle = {
        id: "gaugeNeedle",
        afterDatasetsDraw(chart, args, plugins) {
          const { ctx, data } = chart;
          ctx.save();
          const xCenter = chart.getDatasetMeta(0).data[0].x;
          const yCenter = chart.getDatasetMeta(0).data[0].y;

          const outerRadius = chart.getDatasetMeta(0).data[0].outerRadius;
          const innerRadius = chart.getDatasetMeta(0).data[0].innerRadius;
          const widthSlice = (outerRadius - innerRadius) / 2;
          const radius = 15;
          const angle = Math.PI / 180;

          const needleValue = data.datasets[0].needleValue;

          const dataTotal = data.datasets[0].data.reduce((a, b) => a + b, 0);
          const circumference =
            (chart.getDatasetMeta(0).data[0].circumference /
              Math.PI /
              data.datasets[0].data[0]) *
            data.datasets[0].needle;

          ctx.translate(xCenter, yCenter);
          ctx.rotate(Math.PI * (circumference + 1.5));
          //needle
          ctx.beginPath();
          ctx.strokeStyle = "grey";
          ctx.fillStyle = "grey";
          ctx.moveTo(0 - 15, 0);
          ctx.lineTo(0, 0 - innerRadius - widthSlice);
          ctx.lineTo(0 + 15, 0);
          ctx.closePath();
          ctx.stroke();
          ctx.fill();

          //dot
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, angle * 360, false);
          ctx.fill();
          ctx.restore();
        },
      };
      const gaugeFlowMeter = {
        id: "gaugeFlowMeter",
        afterDatasetsDraw(chart, args, plugins) {
          const { ctx, data } = chart;

          ctx.save();
          const needleValue = data.datasets[0].needleValue;
          const xCenter = chart.getDatasetMeta(0).data[0].x;
          const yCenter = chart.getDatasetMeta(0).data[0].y;
          const chartMetaData = chart.getDatasetMeta(0);

          const circumference =
            (chart.getDatasetMeta(0).data[0].circumference /
              Math.PI /
              data.datasets[0].data[0]) *
            data.datasets[0].needle;

          //flowmeter
          ctx.fillStyle = "black";
          ctx.font = "30px Arial";
          ctx.textAlign = "center";
          ctx.fillText(data.datasets[0].needle + " kwh", xCenter, yCenter + 40);
        },
      };
      const gaugeLabels = {
        id: "gaugeLabels",
        afterDatasetsDraw(chart, args, plugins) {
          const { ctx, data } = chart;
          ctx.save();
          const xCenter = chart.getDatasetMeta(0).data[0].x;
          const yCenter = chart.getDatasetMeta(0).data[0].y;
          const outer = chart.getDatasetMeta(0).data[0].outerRadius;
          const inner = chart.getDatasetMeta(0).data[0].innerRadius;
          ctx.fillStyle = "black";
          ctx.font = "30px Arial";
          ctx.textAlign = "center";
          ctx.fillText(data.datasets[0].label, xCenter, yCenter - outer - 10);
          ctx.restore();
        },
      };
      const gaugeConfig = {
        type: "doughnut",
        data: gaugeData,
        options: {
          layout: {
            padding: 20,
          },
          animation: {
            animateRotate: false, // Disable rotation animation
          },
          aspectRatio: 1.2,
          plugins: {
            legend: {
              display: false,
            },
            tooltip: {
              enabled: false,
            },
          },
        },
        plugins: [gaugeNeedle, gaugeFlowMeter, gaugeLabels],
      };
      function loadTempChart(key) {
        var temp = [];
        var labels = [];

        // Get the sensor data for the given zone key
        var zoneData = sensordata[key];
        if (zoneData) {
          // Iterate over the sensor data and push to temp and labels arrays
          for (var i = 0; i < zoneData.length; i++) {
            temp.push(zoneData[i].temperature);
            labels.push(zoneData[i].timestamp);
          }
        }
        temp.reverse();
        labels.reverse();

        var tempChart = document.getElementById("tempChart");
        var tempCtx = tempChart.getContext("2d");
        var time = new Date().toISOString().split("T")[1].substring(0, 8);
        var data = {
          labels: labels,
          datasets: [
            {
              label: "temperature",
              data: temp,
              fill: false,
              hoverBackgroundColor: "rgba(75, 192, 192, 0.4)",
              borderColor: "rgb(75, 192, 192)",
              tension: 0.1,
            },
          ],
        };
        var tempConfig = {
          type: "line",
          data: data,
        };
        var tsdf = new Chart(tempCtx, tempConfig);
      }
      createArea();
      updatetemperature();
      var ctx1 = document.getElementById("myChart1").getContext("2d");
      var myChart1 = new Chart(ctx1, gaugeConfig);
    </script>
  </body>
</html>
